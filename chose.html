<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>å°ˆæ¥­ç´šç‰©ç†æŠ½çæ©Ÿ V3.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; font-family: "PingFang TC", "Microsoft JhengHei", sans-serif; color: white; overflow: hidden; }
        #setup-screen { position: fixed; inset: 0; background: rgba(30, 30, 30, 0.95); z-index: 1000; padding: 40px; overflow-y: auto; display: flex; flex-direction: column; align-items: center; }
        .list-container { width: 100%; max-width: 600px; background: #333; border-radius: 12px; padding: 20px; margin: 20px 0; }
        .player-item { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; background: #444; padding: 10px; border-radius: 8px; }
        .player-item img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; }
        .player-item input { background: #222; border: 1px solid #555; color: white; padding: 5px 10px; border-radius: 4px; flex-grow: 1; }
        
        #leaderboard { position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; width: 180px; z-index: 100; border: 1px solid #ffd700; }
        .leader-item { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; font-size: 14px; }
        .leader-item img { width: 30px; height: 30px; border-radius: 50%; }
        .rank { font-weight: bold; color: #ffd700; min-width: 20px; }

        #winner-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; color: #222; padding: 40px; border-radius: 24px; text-align: center; display: none; z-index: 2000; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        #winner-popup img { width: 180px; height: 180px; border-radius: 50%; border: 8px solid #ffd700; margin: 20px 0; }
        
        .btn { cursor: pointer; background: #ff4757; color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 18px; font-weight: bold; transition: 0.3s; }
        .btn:hover { background: #ff6b81; transform: scale(1.05); }
        .btn:disabled { background: #555; cursor: not-allowed; }
    </style>
</head>
<body>

<div id="setup-screen">
    <h1>ğŸ¡ ç‰©ç†éšœç¤™æŠ½çè³½</h1>
    <p>ä¸Šå‚³ç…§ç‰‡ä¸¦ä¿®æ”¹åç¨±ï¼Œæº–å‚™å¥½å¾Œé»æ“Šé–‹å§‹ï¼</p>
    <input type="file" id="upload" multiple accept="image/*" style="display: none;">
    <button class="btn" onclick="document.getElementById('upload').click()">â• å°å…¥ç…§ç‰‡</button>
    
    <div class="list-container" id="player-list">
        </div>
    
    <button class="btn" id="start-btn" disabled onclick="startRace()">ğŸš€ é‡‹æ”¾çƒé«”</button>
</div>

<div id="leaderboard">
    <div style="text-align:center; font-weight:bold; margin-bottom:10px; border-bottom:1px solid #555;">ğŸ† å³æ™‚é ˜å…ˆ</div>
    <div id="leader-content"></div>
</div>

<div id="winner-popup">
    <h1 style="margin:0">ğŸŠ ä¸­çè€… ğŸŠ</h1>
    <div id="winner-media"></div>
    <h2 id="winner-name-text"></h2>
    <button class="btn" onclick="resetGame()">é‡æ–°ä¸€å±€</button>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

    const WORLD_WIDTH = 600;
    const WORLD_HEIGHT = 6500; // è¶…é•·åœ°åœ–
    let engine, render, runner;
    let players = []; // å­˜å„² {url, name, id}
    let isGameOver = false;

    // åˆå§‹åŒ–ç‰©ç†ç’°å¢ƒ
    function initPhysics() {
        engine = Engine.create();
        render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#1a1a1a',
                hasBounds: true
            }
        });

        // é‚Šç•Œ
        const walls = [
            Bodies.rectangle(WORLD_WIDTH/2, -50, WORLD_WIDTH, 100, { isStatic: true }),
            Bodies.rectangle(-20, WORLD_HEIGHT/2, 40, WORLD_HEIGHT, { isStatic: true }),
            Bodies.rectangle(WORLD_WIDTH+20, WORLD_HEIGHT/2, 40, WORLD_HEIGHT, { isStatic: true }),
            Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT+25, WORLD_WIDTH, 50, { isStatic: true, label: 'goal', render: { fillStyle: '#ffd700' } })
        ];

        // è¤‡é›œæ©Ÿé—œç”Ÿæˆå™¨
        const obstacles = [];
        
        // 1. å¯†é›†é‡˜å­å€ (500-1500)
        for(let y=500; y<1500; y+=100) {
            for(let x=40; x<WORLD_WIDTH; x+=80) {
                obstacles.push(Bodies.circle(x + (y%200===0?30:0), y, 6, { isStatic: true, render: {fillStyle:'#444'} }));
            }
        }

        // 2. æ—‹è½‰æ‰‡è‘‰å€ (1800-3000)
        for(let i=0; i<8; i++) {
            const x = (i%2===0) ? 150 : 450;
            const y = 1800 + (i*250);
            const bar = Bodies.rectangle(x, y, 220, 15, { frictionAir: 0 });
            const pivot = Constraint.create({ pointA: {x, y}, bodyB: bar, stiffness: 1, length: 0 });
            obstacles.push(bar, pivot);
            Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(bar, i%2===0?0.08:-0.08));
        }

        // 3. çª„é“æ¼æ–— (3500)
        obstacles.push(Bodies.rectangle(100, 3500, 400, 20, { isStatic: true, angle: 0.6 }));
        obstacles.push(Bodies.rectangle(500, 3500, 400, 20, { isStatic: true, angle: -0.6 }));

        // 4. äº‚è·³æ¿ (4500-5500)
        for(let i=0; i<15; i++) {
            const x = Math.random() * WORLD_WIDTH;
            const y = 4200 + (Math.random() * 1500);
            obstacles.push(Bodies.rectangle(x, y, 100, 10, { isStatic: true, angle: Math.random()*Math.PI, render: {fillStyle:'#555'} }));
        }

        Composite.add(engine.world, [...walls, ...obstacles]);
        Render.run(render);
        runner = Runner.create();
        Runner.run(runner, engine);

        // é¡é ­èˆ‡æ’åé‚è¼¯
        Events.on(render, 'beforeRender', updateGameLoop);
        Events.on(engine, 'collisionStart', checkWinner);
    }

    // æ­£ç¢ºè£åˆ‡åœ“å½¢åœ–ç‰‡ (Cover æ•ˆæœ)
    async function cropToCircle(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const size = 200; // ç¹ªè£½è§£æåº¦
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.beginPath();
                    ctx.arc(size/2, size/2, size/2, 0, Math.PI*2);
                    ctx.clip();

                    // è¨ˆç®— Cover ç¸®æ”¾
                    const scale = Math.max(size / img.width, size / img.height);
                    const x = (size / 2) - (img.width / 2) * scale;
                    const y = (size / 2) - (img.height / 2) * scale;
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    
                    resolve(canvas.toDataURL());
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    // UI æ§åˆ¶
    document.getElementById('upload').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        for (let file of files) {
            const croppedUrl = await cropToCircle(file);
            const player = { url: croppedUrl, name: file.name.split('.')[0], id: Date.now() + Math.random() };
            players.push(player);
            renderPlayerList();
        }
    });

    function renderPlayerList() {
        const container = document.getElementById('player-list');
        container.innerHTML = players.map((p, index) => `
            <div class="player-item">
                <img src="${p.url}">
                <input type="text" value="${p.name}" onchange="updateName(${index}, this.value)">
                <button onclick="removePlayer(${index})" style="background:none; border:none; color:#ff4757; cursor:pointer;">âœ–</button>
            </div>
        `).join('');
        document.getElementById('start-btn').disabled = players.length === 0;
    }

    function updateName(index, val) { players[index].name = val; }
    function removePlayer(index) { players.splice(index, 1); renderPlayerList(); }

    function startRace() {
        document.getElementById('setup-screen').style.display = 'none';
        isGameOver = false;
        
        players.forEach((p, i) => {
            setTimeout(() => {
                const ball = Bodies.circle(WORLD_WIDTH/2 + (Math.random()*60-30), 80, 28, {
                    restitution: 0.5, friction: 0.02, label: 'ball',
                    render: { sprite: { texture: p.url, xScale: 56/200, yScale: 56/200 } }
                });
                ball.pData = p; // ç¶å®šè³‡æ–™
                Composite.add(engine.world, ball);
            }, i * 250);
        });
    }

    function updateGameLoop() {
        const balls = Composite.allBodies(engine.world).filter(b => b.label === 'ball');
        if (balls.length === 0) return;

        // æ’åè¨ˆç®—
        const sorted = [...balls].sort((a, b) => b.position.y - a.position.y);
        
        // æ›´æ–°é¡é ­ (è·Ÿéš¨é ˜å…ˆè€…)
        const lead = sorted[0];
        const viewHeight = render.options.height;
        let lookAtY = Math.max(viewHeight/2, lead.position.y + 100);
        lookAtY = Math.min(lookAtY, WORLD_HEIGHT - viewHeight/2);

        render.bounds.min.y = lookAtY - viewHeight/2;
        render.bounds.max.y = lookAtY + viewHeight/2;
        render.bounds.min.x = 0;
        render.bounds.max.x = WORLD_WIDTH;

        // æ›´æ–°é ˜å…ˆçœ‹æ¿
        const board = document.getElementById('leader-content');
        board.innerHTML = sorted.slice(0, 3).map((b, i) => `
            <div class="leader-item">
                <span class="rank">${i+1}</span>
                <img src="${b.pData.url}">
                <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${b.pData.name}</span>
            </div>
        `).join('');
    }

    function checkWinner(event) {
        event.pairs.forEach(pair => {
            if (!isGameOver && (pair.bodyA.label === 'goal' || pair.bodyB.label === 'goal')) {
                const ball = pair.bodyA.label === 'ball' ? pair.bodyA : pair.bodyB;
                if (ball.pData) {
                    isGameOver = true;
                    showWinner(ball.pData);
                }
            }
        });
    }

    function showWinner(data) {
        const popup = document.getElementById('winner-popup');
        document.getElementById('winner-media').innerHTML = `<img src="${data.url}">`;
        document.getElementById('winner-name-text').innerText = data.name;
        popup.style.display = 'block';
    }

    function resetGame() {
        // æ¸…é™¤ç‰©ç†ä¸–ç•Œä¸­çš„çƒ
        const balls = Composite.allBodies(engine.world).filter(b => b.label === 'ball');
        balls.forEach(b => Composite.remove(engine.world, b));
        
        // é‡ç½®é¡é ­èˆ‡ç‹€æ…‹
        document.getElementById('winner-popup').style.display = 'none';
        document.getElementById('setup-screen').style.display = 'flex';
        renderPlayerList();
    }

    // å•Ÿå‹•
    initPhysics();
    window.addEventListener('resize', () => {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
    });
</script>
</body>
</html>
