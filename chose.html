<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°ˆæ¥­ç‰ˆç‰©ç†ç…§ç‰‡æŠ½ç</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #121212; font-family: sans-serif; }
        
        /* æ‰‹æ©Ÿç‰ˆä»‹é¢å„ªåŒ– */
        #ui-layer { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 100; background: rgba(0,0,0,0.85); padding: 20px; 
            border-radius: 20px; width: 85%; max-width: 400px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); border: 1px solid #444;
        }
        
        .btn-main { 
            width: 100%; height: 50px; font-size: 18px; font-weight: bold;
            background: #e91e63; color: white; border: none; border-radius: 12px;
            margin-top: 10px; cursor: pointer;
        }
        .btn-main:disabled { background: #444; color: #888; }
        
        input[type="file"] { color: #ccc; font-size: 14px; width: 100%; }

        #winner-display {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); color: white; 
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; text-align: center;
        }
        #winner-display img { 
            width: 220px; height: 220px; border-radius: 50%; 
            border: 8px solid #ffd700; box-shadow: 0 0 30px #ffd700;
            margin: 20px 0;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div style="color: #fff; margin-bottom: 10px; text-align: center; font-weight: bold;">ğŸ“¸ ä¸Šå‚³ç…§ç‰‡é–‹å§‹æŠ½ç</div>
    <input type="file" id="upload" multiple accept="image/*">
    <button id="start-btn" class="btn-main" disabled>è«‹å…ˆä¸Šå‚³ç…§ç‰‡</button>
</div>

<div id="winner-display">
    <h1 style="color: #ffd700; font-size: 40px; margin: 0;">ğŸ† ä¸­çè€… ğŸ†</h1>
    <div id="winner-img-container"></div>
    <h2 id="winner-name" style="font-size: 28px; margin: 10px 0;"></h2>
    <button class="btn-main" style="width: 150px;" onclick="location.reload()">é‡æ–°é–‹å§‹</button>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

    const WORLD_WIDTH = 600;
    const WORLD_HEIGHT = 4500; // è¶…é•·åœ°åœ–å¢åŠ è¶£å‘³æ€§
    const BALL_RADIUS = 30; // åŠ å¤§çƒé«”æ›´æ¸…æ¥š

    let engine, render, runner;
    let photoTextures = [];
    let isGameOver = false;

    function init() {
        engine = Engine.create();
        
        // æ¸²æŸ“å™¨é©æ‡‰è¢å¹•
        render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#1a1a1a',
                hasBounds: true
            }
        });

        const wallOptions = { isStatic: true, render: { fillStyle: '#333' } };
        const obstacles = [];

        // 1. é˜²å¡æ­»é‚Šç•Œè¨­è¨ˆï¼šåœ¨å…©å´åŠ å…¥ä¸‰è§’å½¢æ–œå°è§’
        for (let y = 200; y < WORLD_HEIGHT; y += 400) {
            // å·¦é‚Šå°è§’
            obstacles.push(Bodies.trapezoid(-10, y, 60, 100, 0.5, { ...wallOptions, angle: Math.PI/2 }));
            // å³é‚Šå°è§’
            obstacles.push(Bodies.trapezoid(WORLD_WIDTH + 10, y + 200, 60, 100, 0.5, { ...wallOptions, angle: -Math.PI/2 }));
        }

        // åŸºæœ¬ç‰†å£
        const leftWall = Bodies.rectangle(-10, WORLD_HEIGHT/2, 25, WORLD_HEIGHT, wallOptions);
        const rightWall = Bodies.rectangle(WORLD_WIDTH + 10, WORLD_HEIGHT/2, 25, WORLD_HEIGHT, wallOptions);
        const ground = Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT + 20, WORLD_WIDTH, 60, { 
            isStatic: true, label: 'finish-line', render: { fillStyle: '#ffd700' } 
        });

        // 2. éš¨æ©Ÿé‡˜å­é™£åˆ— (é¿é–‹é‚Šç•Œä»¥é˜²å¤¾æ­»)
        for (let y = 400; y < WORLD_HEIGHT - 400; y += 150) {
            const isEven = (y / 150) % 2 === 0;
            const startX = isEven ? 80 : 120;
            for (let x = startX; x < WORLD_WIDTH - 50; x += 100) {
                obstacles.push(Bodies.circle(x, y, 6, { isStatic: true, render: { fillStyle: '#555' } }));
            }
        }

        // 3. æ—‹è½‰æ©Ÿé—œ
        for (let i = 0; i < 6; i++) {
            const x = WORLD_WIDTH / 2 + (i % 2 === 0 ? -100 : 100);
            const y = 1000 + (i * 550);
            const bar = Bodies.rectangle(x, y, 180, 20, { frictionAir: 0, render: { fillStyle: '#ff9800' } });
            const pivot = Constraint.create({ pointA: { x: x, y: y }, bodyB: bar, stiffness: 1, length: 0 });
            obstacles.push(bar, pivot);
            Events.on(engine, 'beforeUpdate', () => { Body.setAngularVelocity(bar, 0.06); });
        }

        Composite.add(engine.world, [leftWall, rightWall, ground, ...obstacles]);
        Render.run(render);
        runner = Runner.create();
        Runner.run(runner, engine);

        // é¡é ­è‡ªå‹•è·Ÿéš¨
        Events.on(render, 'beforeRender', () => {
            const balls = Composite.allBodies(engine.world).filter(b => b.label === 'player-ball');
            if (balls.length > 0) {
                const leadBall = balls.reduce((max, b) => b.position.y > max.position.y ? b : max, balls[0]);
                const targetY = leadBall.position.y;
                const viewHeight = render.options.height;
                let minTop = Math.max(0, targetY - viewHeight * 0.4); // è®“çƒå‡ºç¾åœ¨ç•«é¢ä¸ŠåŠéƒ¨
                minTop = Math.min(minTop, WORLD_HEIGHT - viewHeight);

                render.bounds.min.x = 0;
                render.bounds.max.x = WORLD_WIDTH;
                render.bounds.min.y = minTop;
                render.bounds.max.y = minTop + viewHeight;
            }
        });

        // ç²å‹åˆ¤æ–·
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                if ((pair.bodyA.label === 'finish-line' || pair.bodyB.label === 'finish-line') && !isGameOver) {
                    const ball = pair.bodyA.label === 'player-ball' ? pair.bodyA : (pair.bodyB.label === 'player-ball' ? pair.bodyB : null);
                    if (ball) announceWinner(ball);
                }
            });
        });
    }

    // ä¿®æ­£çš„æ­£åœ“è£å‰ªå‡½å¼
    async function processImage(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const size = 200; // ä½¿ç”¨è¼ƒå¤§å°ºå¯¸ç¢ºä¿è§£æåº¦
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    
                    // ç¹ªè£½åœ“å½¢è£åˆ‡é¢
                    ctx.beginPath();
                    ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();
                    
                    // è¨ˆç®—ç¸®æ”¾ä»¥å¡«æ»¿åœ“å½¢ (Cover æ•ˆæœ)
                    const scale = Math.max(size / img.width, size / img.height);
                    const x = (size - img.width * scale) / 2;
                    const y = (size - img.height * scale) / 2;
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    
                    resolve({ url: canvas.toDataURL(), name: file.name.split('.')[0] });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    document.getElementById('upload').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        photoTextures = [];
        for (let file of files) {
            const data = await processImage(file);
            photoTextures.push(data);
        }
        const btn = document.getElementById('start-btn');
        btn.disabled = photoTextures.length === 0;
        btn.innerText = `æº–å‚™å°±ç·’ï¼é‡‹æ”¾ ${photoTextures.length} é¡†çƒ`;
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('ui-layer').style.display = 'none';
        
        // 4. åŒæ™‚é‡‹æ”¾ï¼šæ”¹ç”¨å¾ªç’°ç›´æ¥ç”Ÿæˆ
        photoTextures.forEach((data, i) => {
            const xOffset = (i % 5) * 40 - 80; // æ°´å¹³ç¨å¾®éŒ¯é–‹é¿å…é‡ç–Šå¡ä½
            const ball = Bodies.circle(WORLD_WIDTH/2 + xOffset, 100 - (Math.floor(i/5)*70), BALL_RADIUS, {
                restitution: 0.5,
                friction: 0.02,
                label: 'player-ball',
                render: {
                    sprite: {
                        texture: data.url,
                        xScale: (BALL_RADIUS * 2) / 200,
                        yScale: (BALL_RADIUS * 2) / 200
                    }
                }
            });
            ball.playerName = data.name;
            ball.playerImg = data.url;
            Composite.add(engine.world, ball);
        });
    });

    function announceWinner(ball) {
        if (isGameOver) return;
        isGameOver = true;
        setTimeout(() => {
            const display = document.getElementById('winner-display');
            document.getElementById('winner-img-container').innerHTML = `<img src="${ball.playerImg}">`;
            document.getElementById('winner-name').innerText = ball.playerName;
            display.style.display = 'flex';
        }, 500);
    }

    // éš¨æ™‚ä¿®æ­£ç•«å¸ƒå¤§å°
    window.addEventListener('resize', () => {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
    });

    init();
</script>
</body>
</html>
