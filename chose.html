<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 æ–°å¹´ç‰©ç†æŠ½ç - é¦¬å¹´ç‰¹åˆ¥ç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root { 
            --main: #ff3333; /* æ–°å¹´ç´… */
            --gold: #ffd700; /* ç¯€æ…¶é‡‘ */
            --bg: #1a0505;   /* æ·±ç´…é»‘èƒŒæ™¯ */
        }
        body { 
            margin: 0; 
            background: var(--bg); 
            background-image: radial-gradient(circle at center, #3d0000 0%, #1a0505 100%);
            font-family: "PingFang TC", "Microsoft JhengHei", sans-serif; 
            overflow: hidden; 
            position: fixed; 
            width: 100%; 
            height: 100%; 
            color: #eee; 
        }
        
        /* UI é¢æ¿ - æ–°å¹´é¢¨ */
        #ui-panel { 
            position: fixed; left: 10px; top: 10px; width: calc(100% - 130px); 
            max-height: 45vh; background: rgba(50, 0, 0, 0.9); 
            border-radius: 15px; padding: 15px; z-index: 100; 
            border: 2px solid var(--gold); backdrop-filter: blur(10px); overflow-y: auto; 
        }
        .player-row { 
            display: flex; align-items: center; gap: 10px; margin-bottom: 8px; 
            background: rgba(255, 255, 255, 0.1); padding: 8px; border-radius: 10px; 
            border: 1px solid rgba(255, 215, 0, 0.3); 
        }
        .player-row img { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 1px solid var(--gold); }
        .player-row input { background: transparent; border: none; color: #fff; width: 100%; font-size: 13px; outline: none; }
        
        #btn-start { 
            width: 100%; padding: 12px; background: linear-gradient(135deg, #ffd700, #ff8c00); 
            color: #800000; border: none; border-radius: 10px; font-weight: bold; 
            cursor: pointer; font-size: 16px; margin-top: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #btn-start:disabled { background: #444; color: #888; cursor: not-allowed; box-shadow: none; }
        
        /* å³å´æ’è¡Œæ¦œ */
        #leaderboard { 
            position: fixed; right: 10px; top: 10px; width: 80px; 
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 15px; 
            border: 1px solid var(--gold); z-index: 100; 
        }
        .rank-item { position: relative; display: flex; flex-direction: column; align-items: center; margin-bottom: 15px; }
        .rank-item img { width: 50px; height: 50px; border-radius: 50%; border: 2px solid #555; object-fit: cover; }
        .rank-badge { 
            position: absolute; top: -5px; left: -5px; width: 22px; height: 22px; 
            background: var(--gold); color: #800000; border-radius: 50%; 
            font-size: 12px; font-weight: bold; display: flex; align-items: center; 
            justify-content: center; border: 2px solid #800000; z-index: 2; 
        }
        .rank-0 img { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
        
        /* ç²å‹å½ˆçª— - æ–°å¹´ä¸»é¡Œ */
        #win-popup { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: #fff; color: #000; padding: 30px; border-radius: 25px; 
            display: none; flex-direction: column; align-items: center; z-index: 200; 
            width: 75%; text-align: center; 
            box-shadow: 0 0 100px #ff3333; border: 5px solid var(--gold);
        }
        #win-popup::before { content: "ğŸ§§ 2026 Happy New Year ğŸ§§"; font-weight: bold; color: var(--main); margin-bottom: 10px; }
        #win-popup img { width: 160px; height: 160px; border-radius: 50%; border: 6px solid var(--main); object-fit: cover; margin-bottom: 15px; }
        .btn-retry { padding: 12px 30px; background: var(--main); color: #fff; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; font-size: 16px; }
    </style>
</head>
<body>

<div id="ui-panel">
    <div style="font-size: 18px; color: var(--gold); margin-bottom: 12px; font-weight: bold; text-align: center;">ğŸ§¨ 2026 æ–°å¹´ç‰©ç†æŠ½ç ğŸ§¨</div>
    <div style="font-size: 12px; color: #ff9999; text-align: center; margin-bottom: 10px;">é¦¬å¹´è¡Œå¤§é‹ï¼Œå¹¸é‹å…’æ˜¯èª°ï¼Ÿ</div>
    <input type="file" id="file-input" multiple accept="image/*" style="font-size: 12px; margin-bottom: 12px; width: 100%; color: #ccc;">
    <div id="list-area"></div>
    <button id="btn-start" disabled>ç¢ºèªåå–®ï¼Œé»ç«ç™¼å°„ï¼</button>
</div>

<div id="leaderboard">
    <div style="font-size: 10px; color:var(--gold); text-align:center; margin-bottom:10px; letter-spacing: 1px;">ç¦æ°£æ’å</div>
    <div id="rank-list"></div>
</div>

<div id="win-popup">
    <h1 style="margin:0; font-size: 28px; color: #d40000; font-weight: 900;">æ–°å¹´å¿«æ¨‚ ğŸ‰</h1>
    <p style="color: #666; margin: 10px 0;">æ­å–œé€™ä½é¦¬å¹´å¹¸é‹å…’ï¼š</p>
    <div id="win-avatar"></div>
    <h1 id="win-name" style="margin:5px 0 25px 0; font-size: 32px;"></h1>
    <button class="btn-retry" onclick="resetGame()">å†æŠ½ä¸€æ¬¡ (å¤§å‰å¤§åˆ©)</button>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;
const W = 400, H = 10000;
let BALL_R = 22, engine, render, runner, players = [], isGaming = false;
let grandContainer = null; 

const CONTAINER_Y = 600; 
const OBSTACLE_SAFE_GAP = 85; 

function init() {
    engine = Engine.create();
    render = Render.create({
        element: document.body,
        engine: engine,
        options: { 
            width: window.innerWidth, 
            height: window.innerHeight, 
            wireframes: false, 
            background: 'transparent', // æ”¹é€æ˜ç”± CSS æ§åˆ¶èƒŒæ™¯
            hasBounds: true 
        }
    });

    const obs = [];

    // éšœç¤™ç‰©ç”Ÿæˆ
    for (let y = 1000; y < H; y += 180) {
        const r = 15 + Math.random() * 20;
        obs.push(
            Bodies.circle(0, y, r, { isStatic: true, render: { fillStyle: '#4d0000' } }),
            Bodies.circle(W, y + 90, r, { isStatic: true, render: { fillStyle: '#4d0000' } })
        );
        if (y % 360 === 0) {
            obs.push(Bodies.rectangle(15, y+45, 45, 10, { isStatic: true, angle: 0.5, render: { fillStyle: '#ffd700' } }));
            obs.push(Bodies.rectangle(W-15, y+45, 45, 10, { isStatic: true, angle: -0.5, render: { fillStyle: '#ffd700' } }));
        }
    }

    // éš¨æ©Ÿæ©Ÿé—œ (ä¿æŒåŸé‚è¼¯ï¼Œåƒ…ä¿®æ”¹é¡è‰²)
    for (let y = 1200; y < H - 1000; y += 350) {
        const type = Math.floor(Math.random() * 8);
        const xCenter = W / 2;
        const safeX = OBSTACLE_SAFE_GAP + Math.random() * (W - 2 * OBSTACLE_SAFE_GAP);

        if (type === 0) { // æ—‹è½‰åœ“ç›¤
            const rollerR = 35;
            const roller = Bodies.circle(safeX, y, rollerR, { isStatic: true, render: { fillStyle: '#300', strokeStyle: '#ffd700', lineWidth: 4 } });
            obs.push(roller);
            Events.on(engine, 'beforeUpdate', () => Body.setAngle(roller, roller.angle + 0.15));
        } else if (type === 1) { // å·¦å³æ©«ç§»
            const gL = Bodies.rectangle(xCenter - 90, y, 100, 15, { isStatic: true, render: { fillStyle: '#ff3333' } });
            const gR = Bodies.rectangle(xCenter + 90, y, 100, 15, { isStatic: true, render: { fillStyle: '#ff3333' } });
            obs.push(gL, gR);
            Events.on(engine, 'beforeUpdate', () => {
                const move = Math.sin(engine.timing.timestamp * 0.003) * 60;
                Body.setPosition(gL, { x: xCenter - 120 + move, y: y });
                Body.setPosition(gR, { x: xCenter + 120 - move, y: y });
            });
        } else if (type === 2) { // æ—‹è½‰é¢¨è»Š
            const star = Bodies.rectangle(xCenter, y, 170, 15, { chamfer: { radius: 7 }, render: { fillStyle: '#ffd700' } });
            obs.push(star, Constraint.create({ pointA: { x: xCenter, y: y }, bodyB: star, stiffness: 1 }));
            const spd = (0.05 + Math.random() * 0.1) * (Math.random() > 0.5 ? 1 : -1);
            Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(star, spd));
        } else if (type === 3) { // å½ˆåŠ›æ–œæ¿
            const side = Math.random() > 0.5;
            obs.push(Bodies.rectangle(side ? 100 : 300, y, 180, 20, { isStatic: true, angle: side ? 0.4 : -0.4, restitution: 2.5, render: { fillStyle: '#ff9900' } }));
        } else if (type === 4) { // é‡˜å­è·¯
            const dots = 3;
            const spacing = W / (dots + 1);
            for(let i=1; i<=dots; i++) obs.push(Bodies.circle(i * spacing, y, 12, { isStatic: true, render: { fillStyle: '#600' } }));
        } else if (type === 5) { // æ—‹è½‰ä¸‰è§’å½¢
            const tri = Bodies.polygon(safeX, y, 3, 48, { isStatic: true, render: { fillStyle: '#ff3333' } });
            obs.push(tri);
            Events.on(engine, 'beforeUpdate', () => Body.setAngle(tri, tri.angle - 0.08));
        } else if (type === 6) { // æ»‘å‹•å¹³å°
            const wall = Bodies.rectangle(xCenter, y, 140, 40, { isStatic: true, render: { fillStyle: '#ffd700' } });
            obs.push(wall);
            Events.on(engine, 'beforeUpdate', () => Body.setPosition(wall, { x: xCenter + Math.sin(engine.timing.timestamp * 0.002) * 100, y: y }));
        } else { // æ–æ“ºæœ¨æ¿
            const plank = Bodies.rectangle(xCenter, y, 240, 15, { chamfer: { radius: 5 }, render: { fillStyle: '#600' } });
            obs.push(plank, Constraint.create({ pointA: { x: xCenter, y: y }, bodyB: plank, stiffness: 0.05 }));
        }
    }

    // çµ‚é»æ¼æ–—
    obs.push(
        Bodies.rectangle(50, H-600, 250, 40, { isStatic: true, angle: 0.8, render: { fillStyle: '#ffd700' } }),
        Bodies.rectangle(350, H-600, 250, 40, { isStatic: true, angle: -0.8, render: { fillStyle: '#ffd700' } })
    );

    const goal = Bodies.rectangle(W/2, H+50, W, 120, { isStatic: true, label: 'goal', render: { fillStyle: '#ff3333' } });
    Composite.add(engine.world, [
        Bodies.rectangle(-22, H/2, 45, H, { isStatic: true, render: { fillStyle: '#000' } }),
        Bodies.rectangle(W+22, H/2, 45, H, { isStatic: true, render: { fillStyle: '#000' } }),
        goal, ...obs
    ]);

    Render.run(render);
    Runner.run(Runner.create(), engine);

    Events.on(render, 'afterRender', () => {
        const balls = Composite.allBodies(engine.world).filter(b => b.label === 'p');
        if (!balls.length) {
            const vh = render.options.height;
            render.bounds.min.y = Math.max(0, CONTAINER_Y - vh/2);
            render.bounds.max.y = render.bounds.min.y + vh;
            return;
        }

        if (grandContainer) {
            Body.setAngle(grandContainer, grandContainer.angle + 0.12);
        }

        const sorted = [...balls].sort((a, b) => b.position.y - a.position.y);
        document.getElementById('rank-list').innerHTML = sorted.slice(0, 3).map((b, i) => `
            <div class="rank-item rank-${i}">
                <div class="rank-badge">${i + 1}</div>
                <img src="${b.pUrl}">
                <div class="rank-name">${b.pName}</div>
            </div>
        `).join('');
        
        const vh = render.options.height;
        let focusY = isGaming ? sorted[0].position.y : CONTAINER_Y;
        let ty = Math.min(Math.max(0, focusY - vh/2), H - vh);
        render.bounds.min.y = ty; render.bounds.max.y = ty + vh;
        render.bounds.min.x = 0; render.bounds.max.x = W;
    });

    Events.on(engine, 'collisionStart', (e) => {
        e.pairs.forEach(p => {
            if ((p.bodyA.label === 'goal' || p.bodyB.label === 'goal') && isGaming) {
                const b = p.bodyA.label === 'p' ? p.bodyA : (p.bodyB.label === 'p' ? p.bodyB : null);
                if (b) { isGaming = false; showWin(b); }
            }
        });
    });

    createGrandContainer();
}

function createGrandContainer() {
    const segments = 16;
    const radius = 130;
    const centerX = 200, centerY = CONTAINER_Y;
    const parts = [];
    for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        const part = Bodies.rectangle(x, y, 60, 10, {
            isStatic: true,
            angle: angle + Math.PI / 2,
            render: { fillStyle: '#ffd700', opacity: 0.6 }
        });
        parts.push(part);
    }
    grandContainer = Body.create({ parts: parts, isStatic: true });
    Composite.add(engine.world, grandContainer);
}

async function prepImg(file) {
    return new Promise(res => {
        const r = new FileReader();
        r.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const c = document.createElement('canvas');
                c.width = c.height = 300;
                const x = c.getContext('2d');
                const s = Math.min(img.width, img.height);
                x.beginPath(); x.arc(150, 150, 150, 0, Math.PI*2); x.clip();
                x.drawImage(img, (img.width-s)/2, (img.height-s)/2, s, s, 0, 0, 300, 300);
                res(c.toDataURL());
            };
            img.src = e.target.result;
        };
        r.readAsDataURL(file);
    });
}

document.getElementById('file-input').addEventListener('change', async (e) => {
    for (let f of Array.from(e.target.files)) {
        const url = await prepImg(f), name = f.name.split('.')[0], id = Math.random();
        players.push({ id, url, name });
        
        const b = Bodies.circle(200 + (Math.random()-0.5)*50, CONTAINER_Y + (Math.random()-0.5)*50, BALL_R, {
            restitution: 0.6, friction: 0.01, label: 'p',
            render: { sprite: { texture: url, xScale: (BALL_R*2)/300, yScale: (BALL_R*2)/300 } }
        });
        b.pName = name; b.pUrl = url;
        Composite.add(engine.world, b);

        const d = document.createElement('div');
        d.className = 'player-row';
        d.innerHTML = `<img src="${url}"><input type="text" value="${name}" oninput="players.find(p=>p.id===${id}).name=this.value">`;
        document.getElementById('list-area').appendChild(d);
    }
    document.getElementById('btn-start').disabled = false;
});

document.getElementById('btn-start').addEventListener('click', () => {
    if (!grandContainer) return;
    isGaming = true; 
    document.getElementById('ui-panel').style.display = 'none';
    
    Composite.remove(engine.world, grandContainer);
    grandContainer = null;

    const balls = Composite.allBodies(engine.world).filter(b => b.label === 'p');
    balls.forEach(b => {
        Body.applyForce(b, b.position, { x: (Math.random()-0.5)*0.05, y: (Math.random()-0.5)*0.05 });
    });
});

function showWin(b) {
    document.getElementById('win-avatar').innerHTML = `<img src="${b.pUrl}">`;
    document.getElementById('win-name').innerText = b.pName;
    document.getElementById('win-popup').style.display = 'flex';
}

function resetGame() {
    Composite.remove(engine.world, Composite.allBodies(engine.world).filter(b => b.label === 'p'));
    if (grandContainer) Composite.remove(engine.world, grandContainer);
    
    document.getElementById('win-popup').style.display = 'none';
    document.getElementById('ui-panel').style.display = 'block';
    isGaming = false;
    
    createGrandContainer();
    
    players.forEach(p => {
        const b = Bodies.circle(200 + (Math.random()-0.5)*50, CONTAINER_Y + (Math.random()-0.5)*50, BALL_R, {
            restitution: 0.6, friction: 0.01, label: 'p',
            render: { sprite: { texture: p.url, xScale: (BALL_R*2)/300, yScale: (BALL_R*2)/300 } }
        });
        b.pName = p.name; b.pUrl = p.url;
        Composite.add(engine.world, b);
    });
}

init();
</script>
</body>
</html>
