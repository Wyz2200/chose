<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é«˜è³ªæ„Ÿç‰©ç†æŠ½ç App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0f0f0f; font-family: "PingFang TC", "Microsoft JhengHei", sans-serif; }
        
        #ui-layer { 
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 100; background: rgba(20,20,20,0.9); padding: 25px; 
            border-radius: 24px; width: 85%; max-width: 420px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8); border: 1px solid #333;
            backdrop-filter: blur(10px); color: white; text-align: center;
        }
        
        .btn-main { 
            width: 100%; height: 55px; font-size: 18px; font-weight: bold;
            background: linear-gradient(135deg, #ff416c, #ff4b2b); color: white; border: none; border-radius: 15px;
            margin-top: 15px; cursor: pointer; transition: transform 0.2s;
        }
        .btn-main:active { transform: scale(0.95); }
        .btn-main:disabled { background: #333; color: #666; cursor: not-allowed; }

        #winner-display {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); color: white; 
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; animation: fadeIn 0.5s;
        }
        #winner-display img { 
            width: 200px; height: 200px; border-radius: 50%; 
            border: 6px solid #ffd700; box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>

<div id="ui-layer">
    <div style="font-size: 20px; margin-bottom: 15px; font-weight: 600;">ğŸ° çµ‚æ¥µç‰©ç†æŠ½ç</div>
    <input type="file" id="upload" multiple accept="image/*" style="margin-bottom: 10px;">
    <div id="status" style="font-size: 13px; color: #aaa;">è«‹é¸å–åŒ…å«æª”åçš„ç…§ç‰‡</div>
    <button id="start-btn" class="btn-main" disabled>æº–å‚™ä¸­...</button>
</div>

<div id="winner-display">
    <h2 style="color: #ffd700; letter-spacing: 5px;">CONGRATULATIONS</h2>
    <div id="winner-img-container"></div>
    <h1 id="winner-name" style="font-size: 36px; margin: 20px 0;"></h1>
    <button class="btn-main" style="width: 180px;" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

    const WORLD_WIDTH = 600;
    const WORLD_HEIGHT = 6000; // æ›´é•·çš„åœ°åœ–
    const BALL_RADIUS = 32;

    let engine, render, runner;
    let photoTextures = [];
    let isGameOver = false;

    function init() {
        engine = Engine.create();
        render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#0f0f0f',
                hasBounds: true,
                pixelRatio: window.devicePixelRatio // è§£æ±ºé‹¸é½’é—œéµ
            }
        });

        const wallOptions = { isStatic: true, render: { fillStyle: '#1a1a1a' } };
        const obstacles = [];

        // 1. é‚Šç•Œèˆ‡å°æµç‰‡
        const leftWall = Bodies.rectangle(-20, WORLD_HEIGHT/2, 40, WORLD_HEIGHT, wallOptions);
        const rightWall = Bodies.rectangle(WORLD_WIDTH + 20, WORLD_HEIGHT/2, 40, WORLD_HEIGHT, wallOptions);
        const ground = Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT + 30, WORLD_WIDTH, 100, { 
            isStatic: true, label: 'finish-line', render: { fillStyle: '#ffd700' } 
        });

        // 2. è±å¯Œæ©Ÿé—œè¨­è¨ˆ
        for (let y = 500; y < WORLD_HEIGHT - 500; y += 600) {
            // A. éš¨æ©Ÿæ—‹è½‰é–€
            const rotators = 3;
            for(let j=0; j<rotators; j++) {
                const rx = (WORLD_WIDTH / (rotators + 1)) * (j + 1);
                const bar = Bodies.rectangle(rx, y, 140, 15, { frictionAir: 0, render: { fillStyle: '#444' } });
                const pivot = Constraint.create({ pointA: { x: rx, y: y }, bodyB: bar, stiffness: 1 });
                obstacles.push(bar, pivot);
                const speed = (j % 2 === 0 ? 0.07 : -0.07);
                Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(bar, speed));
            }

            // B. ç§»å‹•ç‰†æ©Ÿé—œ (å·¦å³å¹³ç§»)
            const slider = Bodies.rectangle(WORLD_WIDTH/2, y + 300, 250, 20, { isStatic: true, render: { fillStyle: '#ff416c' } });
            obstacles.push(slider);
            let time = 0;
            Events.on(engine, 'beforeUpdate', () => {
                time += 0.02;
                const px = WORLD_WIDTH/2 + Math.sin(time) * 150;
                Body.setPosition(slider, { x: px, y: y + 300 });
            });

            // C. å¯†é›†é‡˜å­å€
            for(let k=0; k<15; k++) {
                const px = Math.random() * (WORLD_WIDTH - 100) + 50;
                const py = y + 450 + (Math.random() * 100);
                obstacles.push(Bodies.circle(px, py, 8, { isStatic: true, render: { fillStyle: '#222' } }));
            }
        }

        Composite.add(engine.world, [leftWall, rightWall, ground, ...obstacles]);
        Render.run(render);
        Runner.run(Runner.create(), engine);

        // é¡é ­è·Ÿéš¨èˆ‡ç¹ªè£½åç¨±
        Events.on(render, 'afterRender', () => {
            const context = render.context;
            const balls = Composite.allBodies(engine.world).filter(b => b.label === 'player-ball');
            
            // é¡é ­é‚è¼¯
            if (balls.length > 0) {
                const leadBall = balls.reduce((max, b) => b.position.y > max.position.y ? b : max, balls[0]);
                const viewHeight = render.options.height;
                let minTop = Math.max(0, leadBall.position.y - viewHeight * 0.4);
                minTop = Math.min(minTop, WORLD_HEIGHT - viewHeight);
                render.bounds.min.y = minTop;
                render.bounds.max.y = minTop + viewHeight;
                render.bounds.min.x = 0;
                render.bounds.max.x = WORLD_WIDTH;

                // åœ¨çƒé«”ä¸‹æ–¹ç•«å‡ºåå­— (è‡ªè¨‚åç¨±åŠŸèƒ½)
                context.font = "bold 16px Arial";
                context.fillStyle = "white";
                context.textAlign = "center";
                context.shadowBlur = 4;
                context.shadowColor = "black";
                
                balls.forEach(ball => {
                    const screenPos = {
                        x: (ball.position.x - render.bounds.min.x) * (render.canvas.width / (render.bounds.max.x - render.bounds.min.x)),
                        y: (ball.position.y - render.bounds.min.y) * (render.canvas.height / (render.bounds.max.y - render.bounds.min.y))
                    };
                    context.fillText(ball.playerName, screenPos.x, screenPos.y + BALL_RADIUS + 20);
                });
            }
        });

        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                if ((pair.bodyA.label === 'finish-line' || pair.bodyB.label === 'finish-line') && !isGameOver) {
                    const ball = pair.bodyA.label === 'player-ball' ? pair.bodyA : (pair.bodyB.label === 'player-ball' ? pair.bodyB : null);
                    if (ball) announceWinner(ball);
                }
            });
        });
    }

    async function processImage(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const size = 256; // é«˜è§£æåº¦
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    
                    // ç¹ªè£½ç™½è‰²æé‚Šåœ“å½¢
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(size/2, size/2, size/2 - 5, 0, Math.PI * 2);
                    ctx.clip();
                    const scale = Math.max(size / img.width, size / img.height);
                    ctx.drawImage(img, (size-img.width*scale)/2, (size-img.height*scale)/2, img.width*scale, img.height*scale);
                    ctx.restore();

                    // å¤–åœˆè³ªæ„Ÿæ¡†
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 10;
                    ctx.stroke();
                    
                    resolve({ url: canvas.toDataURL(), name: file.name.split('.')[0] });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    document.getElementById('upload').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        photoTextures = [];
        for (let file of files) {
            photoTextures.push(await processImage(file));
        }
        const btn = document.getElementById('start-btn');
        btn.disabled = false;
        btn.innerText = `åŒæ™‚é‡‹æ”¾ ${photoTextures.length} ä½é¸æ‰‹`;
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('ui-layer').style.display = 'none';
        photoTextures.forEach((data, i) => {
            const col = i % 4;
            const row = Math.floor(i / 4);
            const ball = Bodies.circle(150 + col * 100, 100 - row * 80, BALL_RADIUS, {
                restitution: 0.4, friction: 0.01, label: 'player-ball',
                render: { sprite: { texture: data.url, xScale: (BALL_RADIUS*2)/256, yScale: (BALL_RADIUS*2)/256 } }
            });
            ball.playerName = data.name;
            ball.playerImg = data.url;
            Composite.add(engine.world, ball);
        });
    });

    function announceWinner(ball) {
        isGameOver = true;
        const display = document.getElementById('winner-display');
        document.getElementById('winner-img-container').innerHTML = `<img src="${ball.playerImg}">`;
        document.getElementById('winner-name').innerText = ball.playerName;
        display.style.display = 'flex';
    }

    init();
</script>
</body>
</html>
