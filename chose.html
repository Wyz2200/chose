<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çµ‚æ¥µé˜²å¡æ­»ç…§ç‰‡æŠ½çæ©Ÿ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0f0f13; font-family: "PingFang TC", "Microsoft JhengHei", sans-serif; }
        #ui-layer { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 20px; border-radius: 20px; width: 85%; max-width: 400px; text-align: center; border: 1px solid rgba(255,255,255,0.2); color: white; }
        .btn-main { width: 100%; height: 55px; font-size: 18px; font-weight: bold; background: linear-gradient(45deg, #ff416c, #ff4b2b); color: white; border: none; border-radius: 12px; margin-top: 15px; cursor: pointer; box-shadow: 0 4px 15px rgba(255,65,108,0.4); }
        .btn-main:disabled { background: #333; box-shadow: none; color: #666; }
        #winner-display { position: fixed; inset: 0; background: rgba(0,0,0,0.95); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; }
        #winner-display img { width: 200px; height: 200px; border-radius: 50%; border: 10px solid #ffd700; margin: 20px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div style="font-size: 20px; margin-bottom: 10px;">ğŸ† ç‰©ç†ç…§ç‰‡æŠ½çè³½</div>
    <input type="file" id="upload" multiple accept="image/*">
    <button id="start-btn" class="btn-main" disabled>è«‹ä¸Šå‚³ 1 å¼µä»¥ä¸Šç…§ç‰‡</button>
</div>

<div id="winner-display">
    <h1 style="color: #ffd700; font-size: 48px;">æ­å–œä¸­çï¼</h1>
    <div id="winner-img-container"></div>
    <h2 id="winner-name" style="font-size: 32px;"></h2>
    <button class="btn-main" style="width: 200px;" onclick="location.reload()">é‡æ–°æŒ‘æˆ°</button>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

    const WORLD_WIDTH = 600;
    const WORLD_HEIGHT = 4000;
    const BALL_RADIUS = 35; // åŠ å¤§çƒé«”

    let engine, render, runner;
    let players = []; 
    let isGameOver = false;

    function init() {
        engine = Engine.create();
        engine.gravity.y = 1.2; // å¢åŠ é‡åŠ›è®“çƒæ‰æ›´å¿«ï¼Œä¸æ˜“å¡ä½

        render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#0f0f13',
                hasBounds: true
            }
        });

        // ç‰†å£ï¼šæ‘©æ“¦åŠ›è¨­ç‚º 0ï¼Œä¸”å¢åŠ å½ˆæ€§
        const wallOptions = { isStatic: true, friction: 0, restitution: 0.8, render: { fillStyle: '#222' } };
        const leftWall = Bodies.rectangle(-15, WORLD_HEIGHT/2, 30, WORLD_HEIGHT, wallOptions);
        const rightWall = Bodies.rectangle(WORLD_WIDTH + 15, WORLD_HEIGHT/2, 30, WORLD_HEIGHT, wallOptions);
        const ground = Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT + 30, WORLD_WIDTH, 60, { isStatic: true, label: 'finish', render: { fillStyle: '#ffd700' } });

        // éšœç¤™ç‰©ï¼šå°‡é‡˜å­æ”¹å°ï¼Œé¿å…çƒé«”è·¨åå…¶ä¸Š
        const obstacles = [];
        for (let y = 500; y < WORLD_HEIGHT - 300; y += 200) {
            const isEven = (y / 200) % 2 === 0;
            for (let x = 60; x < WORLD_WIDTH; x += 120) {
                const xPos = isEven ? x : x + 60;
                obstacles.push(Bodies.circle(xPos, y, 4, { isStatic: true, friction: 0, render: { fillStyle: '#444' } }));
            }
        }

        Composite.add(engine.world, [leftWall, rightWall, ground, ...obstacles]);
        Render.run(render);
        runner = Runner.create();
        Runner.run(runner, engine);

        // æ¯ç§’æª¢æŸ¥çƒé«”æ˜¯å¦éœæ­¢ï¼Œè‹¥éœæ­¢å‰‡çµ¦äºˆæ¨åŠ›ï¼ˆé˜²å¡æ­»æ ¸å¿ƒï¼‰
        Events.on(engine, 'afterUpdate', () => {
            if (isGameOver) return;
            const balls = Composite.allBodies(engine.world).filter(b => b.label === 'ball');
            balls.forEach(ball => {
                if (ball.speed < 0.2) { // å¦‚æœçƒå¿«åœäº†
                    Body.applyForce(ball, ball.position, { x: (Math.random() - 0.5) * 0.05, y: -0.02 });
                }
            });
        });

        // é¡é ­è·Ÿéš¨
        Events.on(render, 'beforeRender', () => {
            const balls = Composite.allBodies(engine.world).filter(b => b.label === 'ball');
            if (balls.length > 0) {
                const leadBall = balls.reduce((max, b) => b.position.y > max.position.y ? b : max, balls[0]);
                let targetY = leadBall.position.y - render.options.height * 0.4;
                targetY = Math.max(0, Math.min(targetY, WORLD_HEIGHT - render.options.height));
                render.bounds.min.y = targetY;
                render.bounds.max.y = targetY + render.options.height;
                render.bounds.min.x = 0;
                render.bounds.max.x = WORLD_WIDTH;
            }
        });

        // åˆ¤å®šä¸­ç
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                if ((pair.bodyA.label === 'finish' || pair.bodyB.label === 'finish') && !isGameOver) {
                    const ball = pair.bodyA.label === 'ball' ? pair.bodyA : (pair.bodyB.label === 'ball' ? pair.bodyB : null);
                    if (ball) showWinner(ball);
                }
            });
        });
    }

    // åœ–ç‰‡è™•ç†ï¼šç¢ºä¿ 1:1 æ­£åœ“ä¸”æŠ“å–æª”å
    async function processFile(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 200; canvas.height = 200;
                    const ctx = canvas.getContext('2d');
                    ctx.beginPath();
                    ctx.arc(100, 100, 100, 0, Math.PI*2);
                    ctx.clip();
                    const side = Math.min(img.width, img.height);
                    ctx.drawImage(img, (img.width-side)/2, (img.height-side)/2, side, side, 0, 0, 200, 200);
                    resolve({ url: canvas.toDataURL(), name: file.name.split('.')[0] });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    document.getElementById('upload').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        players = [];
        for (let f of files) {
            players.push(await processFile(f));
        }
        document.getElementById('start-btn').disabled = false;
        document.getElementById('start-btn').innerText = `å•Ÿå‹•æ¯”è³½ (å…± ${players.length} å)`;
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('ui-layer').style.display = 'none';
        players.forEach((data, i) => {
            const ball = Bodies.circle(100 + (i * 80) % (WORLD_WIDTH - 200), -i * 60, BALL_RADIUS, {
                restitution: 0.6, friction: 0, frictionAir: 0.005,
                label: 'ball',
                render: {
                    sprite: { texture: data.url, xScale: (BALL_RADIUS*2)/200, yScale: (BALL_RADIUS*2)/200 }
                }
            });
            ball.playerName = data.name;
            ball.playerImg = data.url;
            Composite.add(engine.world, ball);
        });
    });

    function showWinner(ball) {
        isGameOver = true;
        document.getElementById('winner-img-container').innerHTML = `<img src="${ball.playerImg}">`;
        document.getElementById('winner-name').innerText = ball.playerName;
        document.getElementById('winner-display').style.display = 'flex';
    }

    init();
</script>
</body>
</html>
