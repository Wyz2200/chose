<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç…§ç‰‡ç‰©ç†ç¢°æ’æŠ½çæ©Ÿ - é•·åœ°åœ–ç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #222; font-family: "Microsoft JhengHei", sans-serif; color: white; }
        #ui-layer { position: fixed; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; }
        canvas { display: block; }
        #winner-display {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); color: #333; padding: 30px;
            border-radius: 20px; text-align: center; display: none; z-index: 200;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        #winner-display img { width: 150px; height: 150px; border-radius: 50%; border: 5px solid #ffd700; }
        button { cursor: pointer; background: #ff4757; color: white; border: none; padding: 8px 15px; border-radius: 5px; font-weight: bold; }
        button:disabled { background: #555; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3>ğŸ¡ ç…§ç‰‡ç‰©ç†æŠ½ç</h3>
    <input type="file" id="upload" multiple accept="image/*" style="margin-bottom: 10px;"><br>
    <button id="start-btn" disabled>è«‹å…ˆä¸Šå‚³ç…§ç‰‡</button>
    <p id="status" style="font-size: 12px; margin-top: 5px;">ç›®å‰ç…§ç‰‡æ•¸ï¼š0</p>
</div>

<div id="winner-display">
    <h1>ğŸŠ æ­å–œä¸­ç ğŸŠ</h1>
    <div id="winner-img-container"></div>
    <h2 id="winner-name"></h2>
    <button onclick="location.reload()">é‡æ–°é–‹å§‹</button>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

    // è¨­å®š
    const WORLD_WIDTH = 600;
    const WORLD_HEIGHT = 4000; // é•·åº¦å¯ä»¥è‡ªç”±èª¿æ•´
    const BALL_RADIUS = 25;

    let engine, render, runner;
    let photoTextures = [];
    let isGameOver = false;

    function init() {
        engine = Engine.create();
        render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#1a1a1a',
                hasBounds: true
            }
        });

        // å»ºç«‹é‚Šç•Œ
        const walls = [
            Bodies.rectangle(WORLD_WIDTH/2, -50, WORLD_WIDTH, 100, { isStatic: true }), // é ‚éƒ¨
            Bodies.rectangle(-10, WORLD_HEIGHT/2, 20, WORLD_HEIGHT, { isStatic: true }), // å·¦ç‰†
            Bodies.rectangle(WORLD_WIDTH+10, WORLD_HEIGHT/2, 20, WORLD_HEIGHT, { isStatic: true }), // å³ç‰†
            Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT + 20, WORLD_WIDTH, 50, { isStatic: true, label: 'finish-line', render: { fillStyle: '#ffd700' } }) // çµ‚é»
        ];

        // éš¨æ©Ÿç”¢ç”Ÿé‡˜å­é—œå¡
        const pins = [];
        for (let y = 300; y < WORLD_HEIGHT - 300; y += 120) {
            const isEven = (y / 120) % 2 === 0;
            for (let x = 50; x < WORLD_WIDTH; x += 80) {
                const xPos = isEven ? x : x + 40;
                pins.push(Bodies.circle(xPos, y, 5, { isStatic: true, render: { fillStyle: '#555' } }));
            }
        }

        // å¢åŠ ä¸€äº›æ—‹è½‰éšœç¤™ç‰©
        for (let i = 0; i < 5; i++) {
            const x = Math.random() * (WORLD_WIDTH - 200) + 100;
            const y = 800 + (i * 600);
            const bar = Bodies.rectangle(x, y, 150, 15, { frictionAir: 0 });
            const pivot = Constraint.create({
                pointA: { x: x, y: y },
                bodyB: bar,
                stiffness: 1,
                length: 0
            });
            pins.push(bar, pivot);
            // è®“å®ƒè‡ªå‹•è½‰å‹•
            Events.on(engine, 'beforeUpdate', () => {
                Body.setAngularVelocity(bar, 0.05);
            });
        }

        Composite.add(engine.world, [...walls, ...pins]);
        Render.run(render);
        runner = Runner.create();
        Runner.run(runner, engine);

        // é¡é ­è·Ÿéš¨é‚è¼¯
        Events.on(render, 'beforeRender', () => {
            const balls = Composite.allBodies(engine.world).filter(b => b.label === 'player-ball');
            if (balls.length > 0) {
                let lowestBall = balls[0];
                balls.forEach(b => {
                    if (b.position.y > lowestBall.position.y) lowestBall = b;
                });

                const targetY = lowestBall.position.y;
                const viewHeight = render.options.height;
                
                // å¹³æ»‘æ»¾å‹•é¡é ­
                let minTop = Math.max(0, targetY - viewHeight * 0.7);
                minTop = Math.min(minTop, WORLD_HEIGHT - viewHeight);

                render.bounds.min.x = 0;
                render.bounds.max.x = WORLD_WIDTH; // é–å®šå¯¬åº¦æ¯”ä¾‹
                render.bounds.min.y = minTop;
                render.bounds.max.y = minTop + viewHeight;
            }
        });

        // ç¢°æ’åµæ¸¬ (çµ‚é»)
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const labels = [pair.bodyA.label, pair.bodyB.label];
                if (labels.includes('finish-line') && labels.includes('player-ball') && !isGameOver) {
                    const ball = pair.bodyA.label === 'player-ball' ? pair.bodyA : pair.bodyB;
                    announceWinner(ball);
                }
            });
        });
    }

    // å°‡åœ–ç‰‡è£åˆ‡ç‚ºåœ“å½¢
    async function processImage(file) {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 150;
                    canvas.height = 150;
                    const ctx = canvas.getContext('2d');
                    ctx.beginPath();
                    ctx.arc(75, 75, 75, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(img, 0, 0, 150, 150);
                    resolve({
                        url: canvas.toDataURL(),
                        name: file.name.split('.')[0]
                    });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    document.getElementById('upload').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        document.getElementById('status').innerText = "è™•ç†ä¸­...";
        for (let file of files) {
            const data = await processImage(file);
            photoTextures.push(data);
        }
        document.getElementById('status').innerText = `ç›®å‰ç…§ç‰‡æ•¸ï¼š${photoTextures.length}`;
        document.getElementById('start-btn').disabled = photoTextures.length === 0;
        document.getElementById('start-btn').innerText = "é–‹å§‹æŠ½çï¼";
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('ui-layer').style.display = 'none';
        photoTextures.forEach((data, i) => {
            setTimeout(() => {
                const ball = Bodies.circle(WORLD_WIDTH/2 + (Math.random()*40-20), 50, BALL_RADIUS, {
                    restitution: 0.6,
                    friction: 0.1,
                    label: 'player-ball',
                    render: {
                        sprite: {
                            texture: data.url,
                            xScale: (BALL_RADIUS * 2) / 150,
                            yScale: (BALL_RADIUS * 2) / 150
                        }
                    }
                });
                ball.playerName = data.name;
                ball.playerImg = data.url;
                Composite.add(engine.world, ball);
            }, i * 300);
        });
    });

    function announceWinner(ball) {
        isGameOver = true;
        const display = document.getElementById('winner-display');
        document.getElementById('winner-img-container').innerHTML = `<img src="${ball.playerImg}">`;
        document.getElementById('winner-name').innerText = ball.playerName;
        display.style.display = 'block';
    }

    window.addEventListener('resize', () => {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
    });

    init();
</script>
</body>
</html>
