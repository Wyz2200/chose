<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>物理抽獎 16.0 - 瞬間挑戰版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root { --main: #00ffa2; --bg: #050505; }
        body { margin: 0; background: var(--bg); font-family: sans-serif; overflow: hidden; position: fixed; width: 100%; height: 100%; }
        #ui-panel { position: fixed; left: 10px; top: 10px; width: calc(100% - 130px); max-height: 40vh; background: rgba(20,20,20,0.9); border-radius: 15px; padding: 12px; z-index: 100; border: 1px solid #444; backdrop-filter: blur(10px); overflow-y: auto; }
        .player-row { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; background: #1a1a1a; padding: 5px; border-radius: 8px; }
        .player-row img { width: 35px; height: 35px; border-radius: 50%; object-fit: cover; }
        .player-row input { background: transparent; border: none; color: #fff; width: 100%; font-size: 12px; outline: none; }
        #btn-start { width: 100%; padding: 10px; background: var(--main); color: #000; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        #leaderboard { position: fixed; right: 10px; top: 10px; width: 100px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 15px; z-index: 100; border: 1px solid #333; }
        .rank-item { display: flex; flex-direction: column; align-items: center; margin-bottom: 8px; }
        .rank-item img { width: 40px; height: 40px; border-radius: 50%; border: 2px solid var(--main); object-fit: cover; }
        .rank-name { font-size: 10px; color: #fff; margin-top: 2px; text-align: center; }
        #win-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; color: #000; padding: 30px; border-radius: 25px; display: none; flex-direction: column; align-items: center; z-index: 200; width: 75%; text-align: center; box-shadow: 0 0 50px var(--main); }
        #win-popup img { width: 150px; height: 150px; border-radius: 50%; border: 6px solid var(--main); object-fit: cover; margin-bottom: 15px; }
    </style>
</head>
<body>

<div id="ui-panel">
    <div style="font-size: 14px; color: var(--main); margin-bottom: 8px; font-weight: bold; text-align: center;">INSTANT CHALLENGE 16.0</div>
    <input type="file" id="file-input" multiple accept="image/*" style="font-size: 11px; margin-bottom: 8px; width: 100%;">
    <div id="list-area"></div>
    <button id="btn-start" disabled>開始挑戰！</button>
</div>
<div id="leaderboard"><div id="rank-list"></div></div>
<div id="win-popup"><div id="win-avatar"></div><h1 id="win-name"></h1><button onclick="resetGame()" style="padding:10px 20px; background:#000; color:#fff; border:none; border-radius:8px;">重新挑戰</button></div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body, Vector } = Matter;
const W = 400, H = 10000;
let BALL_R = 22, engine, render, players = [], isGaming = false;
const portals = []; // 用於傳送門配對

function init() {
    engine = Engine.create();
    render = Render.create({
        element: document.body, engine: engine,
        options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: '#050505', hasBounds: true }
    });

    const obs = [];

    // 1. 邊界牆壁 (增加隨機尖刺)
    for (let y = 0; y < H; y += 100) {
        // 固定圓形擾流
        obs.push(Bodies.circle(-10, y, 30, { isStatic: true, render: { fillStyle: '#1a1a1a' } }));
        obs.push(Bodies.circle(W+10, y+50, 30, { isStatic: true, render: { fillStyle: '#1a1a1a' } }));
        
        // 隨機尖刺
        if (Math.random() > 0.7) {
            obs.push(Bodies.polygon(0, y + 25, 3, 20, { isStatic: true, angle: 0.5 + Math.random()*0.5, render: { fillStyle: '#2a2a2a' } }));
            obs.push(Bodies.polygon(W, y + 75, 3, 20, { isStatic: true, angle: -0.5 - Math.random()*0.5, render: { fillStyle: '#2a2a2a' } }));
        }
    }

    // 2. 超高密度隨機機關
    for (let y = 800; y < H - 1000; y += 150) { // 縮短間距到 150px
        const type = Math.floor(Math.random() * 12); // 更多機關類型
        const xC = W / 2;

        if (type === 0) { // 隨機旋轉十字攪拌器
            const x = 80 + Math.random() * (W - 160);
            const cross = Bodies.rectangle(x, y, 120, 15, { render: { fillStyle: '#ff4b2b' } });
            obs.push(cross, Constraint.create({ pointA: { x, y }, bodyB: cross, stiffness: 0.8 }));
            Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(cross, (0.08 + Math.random()*0.05) * (Math.random()>0.5?1:-1)));
        } else if (type === 1) { // 間歇性噴射風口 (向上)
            const jet = Bodies.rectangle(xC + (Math.random()*100-50), y + 20, 50, 10, { isStatic: true, render: { fillStyle: '#00ccff' } });
            obs.push(jet);
            Events.on(engine, 'beforeUpdate', () => {
                if (Math.sin(engine.timing.timestamp * 0.008) > 0.8) { // 每隔一段時間噴射
                    Composite.allBodies(engine.world).filter(b => b.label === 'p').forEach(b => {
                        if (b.position.y > y - 50 && b.position.y < y + 50 && Math.abs(b.position.x - jet.position.x) < 40) {
                            Body.applyForce(b, b.position, { x: 0, y: -0.005 }); // 向上推力
                        }
                    });
                }
            });
        } else if (type === 2) { // 彈簧加速器 (底部)
            const spring = Bodies.rectangle(xC + (Math.random()*100-50), y + 20, 80, 15, { isStatic: true, restitution: 2.5, render: { fillStyle: '#ffde00' } });
            obs.push(spring);
        } else if (type === 3) { // 迷你傳送門 (成對出現)
            if (portals.length % 2 === 0) { // 第一個門
                const p1 = Bodies.circle(80 + Math.random() * (W - 160), y, 15, { isSensor: true, label: 'portal', render: { fillStyle: 'rgba(255,0,255,0.5)' } });
                portals.push(p1); obs.push(p1);
            } else { // 第二個門
                const p2 = Bodies.circle(80 + Math.random() * (W - 160), y, 15, { isSensor: true, label: 'portal', render: { fillStyle: 'rgba(255,0,255,0.5)' } });
                portals.push(p2); obs.push(p2);
                Events.on(engine, 'collisionStart', (e) => {
                    e.pairs.forEach(pair => {
                        let ball = null, portal = null;
                        if (pair.bodyA.label === 'p' && pair.bodyB.label === 'portal') { ball = pair.bodyA; portal = pair.bodyB; }
                        else if (pair.bodyB.label === 'p' && pair.bodyA.label === 'portal') { ball = pair.bodyB; portal = pair.bodyA; }

                        if (ball && portal && ball.lastPortalTime !== engine.timing.timestamp) {
                            const otherPortal = (portal === portals[portals.indexOf(portal)^1]) ? portals[portals.indexOf(portal)^0] : portals[portals.indexOf(portal)^1];
                            if (otherPortal) {
                                Body.setPosition(ball, { x: otherPortal.position.x, y: otherPortal.position.y });
                                Body.setVelocity(ball, { x: ball.velocity.x * 0.8, y: ball.velocity.y * 0.8 }); // 傳送後減速
                                ball.lastPortalTime = engine.timing.timestamp; // 防止連續傳送
                            }
                        }
                    });
                });
            }
        } else if (type === 4) { // 引力黑洞 (物理吸引)
            const hole = Bodies.circle(xC + (Math.random()*100-50), y, 35, { isStatic: true, render: { fillStyle: '#111', strokeStyle: '#ff00ff', lineWidth: 2 } });
            obs.push(hole);
            Events.on(engine, 'beforeUpdate', () => {
                Composite.allBodies(engine.world).filter(b => b.label === 'p').forEach(b => {
                    const dist = Vector.magnitude(Vector.sub(hole.position, b.position));
                    if (dist < 120) {
                        const force = Vector.mult(Vector.normalise(Vector.sub(hole.position, b.position)), 0.0007);
                        Body.applyForce(b, b.position, force);
                    }
                });
            });
        } else if (type === 5) { // 浮動平台 (上下或左右移動)
            const isVertical = Math.random() > 0.5;
            const platform = Bodies.rectangle(xC + (Math.random()*100-50), y, 100, 15, { isStatic: true, render: { fillStyle: '#222' } });
            obs.push(platform);
            Events.on(engine, 'beforeUpdate', () => {
                if (isVertical) Body.setPosition(platform, { x: platform.position.x, y: y + Math.sin(engine.timing.timestamp * 0.003) * 50 });
                else Body.setPosition(platform, { x: xC + Math.sin(engine.timing.timestamp * 0.003) * 80, y: y });
            });
        } else if (type === 6) { // 動態擠壓塊
            const wall = Bodies.rectangle(xC, y, 100, 30, { isStatic: true, render: { fillStyle: '#444' } });
            obs.push(wall);
            Events.on(engine, 'beforeUpdate', () => Body.setPosition(wall, { x: xC + Math.sin(engine.timing.timestamp * 0.002) * 100, y: y }));
        } else if (type === 7) { // 隨機擺錘陣
            for(let i=0; i<3; i++) {
                const ball = Bodies.circle(100 + i*100, y, 18, { restitution: 1, friction: 0 });
                const anchor = Constraint.create({ pointA: { x: 100 + i*100, y: y-60 }, bodyB: ball, stiffness: 0.9 });
                obs.push(ball, anchor);
            }
        } else if (type === 8) { // 藍色彈力加速斜板
            const side = Math.random() > 0.5;
            obs.push(Bodies.rectangle(side?100:300, y, 160, 15, { isStatic: true, angle: side?0.4:-0.4, restitution: 2.2, render: { fillStyle: '#00ccff' } }));
        } else if (type === 9) { // 旋轉齒輪
            const gx = 60 + Math.random() * (W - 120);
            const gear = Bodies.polygon(gx, y, 5, 40, { isStatic: true, render: { fillStyle: '#666' } });
            obs.push(gear);
            Events.on(engine, 'beforeUpdate', () => Body.setAngle(gear, gear.angle + 0.1));
        } else if (type === 10) { // 雙重攪拌棒
            const stirrerL = Bodies.rectangle(xC - 70, y, 100, 10, { render: { fillStyle: '#ff4b2b' } });
            const stirrerR = Bodies.rectangle(xC + 70, y, 100, 10, { render: { fillStyle: '#ff4b2b' } });
            obs.push(stirrerL, stirrerR,
                     Constraint.create({ pointA: { x: xC - 70, y: y }, bodyB: stirrerL, stiffness: 0.9 }),
                     Constraint.create({ pointA: { x: xC + 70, y: y }, bodyB: stirrerR, stiffness: 0.9 }));
            Events.on(engine, 'beforeUpdate', () => {
                const angle = Math.sin(engine.timing.timestamp * 0.003) * 0.5;
                Body.setAngle(stirrerL, angle);
                Body.setAngle(stirrerR, -angle);
            });
        } else { // 擺動長板 (短而密集)
            const plank = Bodies.rectangle(xC + (Math.random()*60-30), y, 180, 12, { render: { fillStyle: '#222' } });
            obs.push(plank, Constraint.create({ pointA: { x: xC, y: y }, bodyB: plank, stiffness: 0.08 }));
        }
    }

    // 終點 V 形與 Goal
    obs.push(Bodies.rectangle(60, H-600, 260, 40, { isStatic: true, angle: 0.8, render: { fillStyle: '#fff' } }));
    obs.push(Bodies.rectangle(340, H-600, 260, 40, { isStatic: true, angle: -0.8, render: { fillStyle: '#fff' } }));
    const goal = Bodies.rectangle(W/2, H+50, W, 120, { isStatic: true, label: 'goal', render: { fillStyle: '#00ffa2' } });

    Composite.add(engine.world, [
        Bodies.rectangle(-25, H/2, 50, H, { isStatic: true, render: { fillStyle: '#000' } }),
        Bodies.rectangle(W+25, H/2, 50, H, { isStatic: true, render: { fillStyle: '#000' } }),
        goal, ...obs
    ]);

    Render.run(render);
    Runner.run(Runner.create(), engine);

    Events.on(render, 'afterRender', () => {
        const balls = Composite.allBodies(engine.world).filter(b => b.label === 'p');
        if (!balls.length) return;
        const sorted = [...balls].sort((a, b) => b.position.y - a.position.y);
        document.getElementById('rank-list').innerHTML = sorted.slice(0, 3).map((b, i) => `
            <div class="rank-item"><img src="${b.pUrl}"><div class="rank-name">${b.pName}</div></div>
        `).join('');
        const vh = render.options.height;
        let ty = Math.min(Math.max(0, sorted[0].position.y - vh/2), H - vh);
        render.bounds.min.y = ty; render.bounds.max.y = ty + vh;
        render.bounds.min.x = 0; render.bounds.max.x = W;
    });

    Events.on(engine, 'collisionStart', (e) => {
        e.pairs.forEach(p => {
            if ((p.bodyA.label === 'goal' || p.bodyB.label === 'goal') && isGaming) {
                const b = p.bodyA.label === 'p' ? p.bodyA : (p.bodyB.label === 'p' ? p.bodyB : null);
                if (b) { isGaming = false; showWin(b); }
            }
        });
    });
}

async function prepImg(file) {
    return new Promise(res => {
        const r = new FileReader();
        r.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const c = document.createElement('canvas'); c.width = c.height = 300;
                const x = c.getContext('2d'); const s = Math.min(img.width, img.height);
                x.beginPath(); x.arc(150, 150, 150, 0, Math.PI*2); x.clip();
                x.drawImage(img, (img.width-s)/2, (img.height-s)/2, s, s, 0, 0, 300, 300);
                res(c.toDataURL());
            }; img.src = e.target.result;
        }; r.readAsDataURL(file);
    });
}

document.getElementById('file-input').addEventListener('change', async (e) => {
    for (let f of Array.from(e.target.files)) {
        const url = await prepImg(f), name = f.name.split('.')[0], id = Math.random();
        players.push({ id, url, name });
        const d = document.createElement('div'); d.className = 'player-row';
        d.innerHTML = `<img src="${url}"><input type="text" value="${name}" oninput="players.find(p=>p.id===${id}).name=this.value">`;
        document.getElementById('list-area').appendChild(d);
    }
    document.getElementById('btn-start').disabled = false;
});

document.getElementById('btn-start').addEventListener('click', () => {
    isGaming = true; document.getElementById('ui-panel').style.display = 'none';
    players.forEach((p, i) => {
        const b = Bodies.circle(W/2 + (Math.random()*40-20), -i*75, BALL_R, {
            restitution: 0.5, friction: 0.005, label: 'p',
            render: { sprite: { texture: p.url, xScale: (BALL_R*2.1)/300, yScale: (BALL_R*2.1)/300 } }
        });
        b.pName = p.name; b.pUrl = p.url;
        Composite.add(engine.world, b);
    });
});

function showWin(b) {
    document.getElementById('win-avatar').innerHTML = `<img src="${b.pUrl}">`;
    document.getElementById('win-name').innerText = b.pName;
    document.getElementById('win-popup').style.display = 'flex';
}

function resetGame() {
    Composite.remove(engine.world, Composite.allBodies(engine.world).filter(b => b.label === 'p'));
    document.getElementById('win-popup').style.display = 'none';
    document.getElementById('ui-panel').style.display = 'block';
    isGaming = false;
    portals.length = 0; // 清空傳送門陣列以重新配對
}

init();
</script>
</body>
</html>
